#!/usr/bin/env node

/*
 * Copyright (c) 2019 oO (https://github.com/oocytanb)
 * MIT Licensed
 *
 * **出力した実データをサンプルとして、仕様不明な状態で仮実装しています。仕様が判明したら適宜修正してお使いください。**
 */

'use strict'

const program = require('commander')
const readline = require('readline')
const WebSocket = require('ws')
const BufferList = require('bl')
const msgpack = require('msgpack5')()

const VciLogRecordType = Object.freeze({
  Unknown: 'unknown',
  Logger: 'logger'
})

const VciLogFormatType = Object.freeze({
  Default: 'default',
  JsonRecord: 'json_record',
  FullText: 'full_text'
})

const parseVciLogRecord = Symbol('parseVciLogRecord')

function controlCodeToString (code) {
  return '<' + (code < 16 ? '0' : '') + code.toString(16) + '>'
}

function isPrintableOrWhitespace (code) {
  return (code >= 0x20 && code <= 0x7E) || (code >= 0x09 && code <= 0x0D)
}

/**
 * VCI のログのレコード。
 */
class VciLogRecord {
  /**
   * @param type {VciLogRecord.RecordType} レコードのタイプ。
   * @param parameterMap {Map} キーペア形式のパラメーターオブジェクト。
   * @param metaList {Array} メタ要素の配列。
   */
  constructor (type, parameterMap, metaList = undefined) {
    this.type = type
    this.metaList = metaList || []
    this.parameterMap = parameterMap || new Map()
  }

  static get RecordType () { return VciLogRecordType }

  static get TextParameterKey () { return '__vci_logcat_text_parameter' }

  static get FormatType () { return VciLogFormatType }

  /**
   * VCI のログのレコードをパースする。
   *
   * @param data {String|Buffer|ArrayBuffer} ws.on('message') で受信したデータを指定する。
   *
   * return {VciLogRecord} パース結果のオブジェクトを返す。
   */
  static parse (data) {
    if (data instanceof String || typeof data === 'string') {
      return new this(VciLogRecordType.Unknown, new Map([[VciLogRecord.TextParameterKey, data]]))
    } else if (data instanceof Buffer) {
      return this[parseVciLogRecord](data)
    } else if (data instanceof ArrayBuffer) {
      return this[parseVciLogRecord](Buffer.from(data))
    } else if (Array.isArray(data)) {
      const bl = new BufferList()
      for (const entry of data) {
        if (entry instanceof Buffer) {
          bl.append(entry)
        }
      }
      return this[parseVciLogRecord](bl)
    } else {
      return new this(VciLogRecordType.Unknown, new Map([[VciLogRecord.TextParameterKey, `[Unsupported data type: ${typeof data}]`]]))
    }
  }

  /**
   * ログレコードのパースを実行する。
   *
   * print() ログのサンプルデータ:
   * ```
   * [
   *   2,
   *   logger,
   *   [
   *     {
   *       "UnixTime": "1550923200",
   *       "Category": "Item_Print",
   *       "LogLevel": "Debug",
   *       "Item": "ITEM_NAME",
   *       "Message": "write {Application.persistentDataPath}/EmbeddedScriptWorkspace/ITEM_NAME/_main.lua",
   *       "CallerFile": "C:\ProgramData\Jenkins\workspace\vrlive-client\Build_Bundle\VRLive\Assets\VRM\VCI-Embedded-Script\Scripts\EmbeddedScriptUnitySide.cs",
   *       "CallerLine": 262,
   *       "CallerMember": "_NewItem"
   *     }
   *   ]
   * ]
   * ```
   *
   * @param bl {Buffer|BufferList} ログデータのバッファー。
   *
   * return {VciLogRecord} パース結果のオブジェクトを返す。
   */
  static [parseVciLogRecord] (buffer) {
    const bl = (buffer instanceof BufferList) ? buffer : new BufferList().append(buffer)

    //
    try {
      const root = msgpack.decode(bl.duplicate())

      if (root instanceof Array &&
          root.length >= 3 && root[1] === 'logger' &&
          root[2] instanceof Array) {
        // VCI ログデータの形式として扱う
        const nodeList = root[2]
        const parameterMap = (nodeList.length >= 1 && typeof nodeList[0] === 'object') ? new Map(Object.entries(nodeList[0])) : new Map()
        const metaList = root.slice(0, 2)
        return new VciLogRecord(VciLogRecordType.Logger, parameterMap, metaList)
      }
    } catch (error) {
    }

    // 不明なデータ形式
    {
      let str = ''
      let controlFlag = false
      for (let i = 0, len = bl.length; i < len; ++i) {
        const cc = bl.get(i)
        if (isPrintableOrWhitespace(cc)) {
          if (controlFlag) {
            str += ' '
          }
          str += String.fromCharCode(cc)
          controlFlag = false
        } else {
          if (str) {
            str += ' '
          }
          str += controlCodeToString(cc)
          controlFlag = true
        }
      }

      return new VciLogRecord(VciLogRecordType.Unknown, new Map([[VciLogRecord.TextParameterKey, str]]))
    }
  }

  toString () {
    return this.format(VciLogRecord.FormatType.Default)
  }

  /**
   * 指定したフォーマットに整形する。
   *
   * @param formatType {VciLogRecord.FormatType} フォーマットを指定する。
   *
   * @return フォーマットした文字列。
   */
  format (formatType) {
    switch (formatType) {
      case VciLogRecord.FormatType.JsonRecord:
        return this._formatJsonRecord()
      case VciLogRecord.FormatType.FullText:
        return this._formatFullText()
      default:
        return this._formatDefault()
    }
  }

  _formatDefault () {
    if (this.type !== VciLogRecordType.Logger) {
      // 不明な形式の場合は、すべての要素を文字列化する
      return this._formatFullText()
    }

    //
    let str = 'Log'

    const timeString = this.parameterMap.get('UnixTime')
    if (timeString !== undefined) {
      const time = Number.parseInt(timeString, 10)
      if (Number.isFinite(time)) {
        const date = new Date(time * 1000)
        str += ` | ${('0' + date.getHours()).slice(-2)}:${('0' + date.getMinutes()).slice(-2)}:${('0' + date.getSeconds()).slice(-2)}`
      }
    }

    for (const key of ['Category', 'Item', 'Message']) {
      const value = this.parameterMap.get(key)
      if (value !== undefined) {
        str += ` | ${value}`
      }
    }

    return str
  }

  _formatJsonRecord () {
    return JSON.stringify({
      type: this.type,
      meta_list: this.metaList,
      parameters: [...this.parameterMap].reduce((acc, [key, value]) => Object.assign(acc, { [key]: value }), {})
    })
  }

  _formatFullText () {
    let str = JSON.stringify(this.metaList)

    for (const [key, value] of this.parameterMap) {
      if (key === VciLogRecord.TextParameterKey) {
        str += (str ? ' | ' : '') + value
      } else {
        str += (str ? ' | ' : '') + key + ' = ' + value
      }
    }

    return str
  }
}

//
program
  .version(require('../package.json').version)
  .usage('[options]')
  .option('-c, --connect <url>', 'connect to VCI WebSocket console (Default: ws://localhost:8080)')
  .option('-f, --format <format>', 'output format (default | json_record | full_text)')
  .option('-A, --all-warnings', 'output all the warnings such as "script not return"')
  .parse(process.argv);

(url => {
  let logFormat
  if (program.format) {
    const formatOption = program.format.toLowerCase()
    const formatTypes = Object.values(VciLogRecord.FormatType)
    const formatIndex = formatTypes.indexOf(formatOption)
    logFormat = formatIndex >= 0 ? formatTypes[formatIndex] : VciLogRecord.FormatType.Default
  } else {
    logFormat = VciLogRecord.FormatType.Default
  }

  const rl = readline.createInterface({ input: process.stdin })

  const destAddress = /\w+:\/\/.*$/i.test(url) ? url : `ws://${url}`
  const ws = new WebSocket(destAddress)

  ws.on('open', () => {
    console.error('connected [%s] (press CTRL+C to quit)', destAddress)
  })

  ws.on('close', code => {
    console.error('disconnected [code: %d]', code)
    process.exit()
  })

  ws.on('error', error => {
    console.error('error: %s', error.message)
    process.exit(-1)
  })

  ws.on('message', data => {
    const record = VciLogRecord.parse(data)

    // TODO フィルター処理を実装
    const outputLog = !!program.allWarnings ||
                      !(record.type === VciLogRecord.RecordType.Logger && record.parameterMap.get('Category') === 'System' && /frame:\s+script\s+not\s+return/.test(record.parameterMap.get('Message'))) // 'frame: script not return' メッセージを無視する

    if (outputLog) {
      console.log(record.format(logFormat))
    }
  })

  rl.on('close', () => {
    ws.close()
    process.exit()
  })
})(program.connect || 'ws://localhost:8080')
