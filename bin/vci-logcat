#!/usr/bin/env node

/*
 * Copyright (c) 2019 oO (https://github.com/oocytanb)
 * MIT Licensed
 *
 * **出力した実データをサンプルとして、仕様不明な状態で仮実装しています。仕様が判明したら適宜修正してお使いください。**
 */

'use strict'

const program = require('commander')
const readline = require('readline')
const WebSocket = require('ws')
const { StringDecoder } = require('string_decoder')

const VciLogRecordType = Object.freeze({
  Unknown: 'unknown',
  Logger: 'logger'
})

const VciLogElementTag = Object.freeze({
  Unknown: 'unknown',
  Tag93: 'tag_93',
  Tag91: 'tag_91',
  Text: 'text',
  Integer: 'integer'
})

const VciLogFormatType = Object.freeze({
  Default: 'default',
  JsonRecord: 'json_record',
  FullText: 'full_text'
})

function controlCodeToString (code) {
  return '<' + (code < 16 ? '0' : '') + code.toString(16) + '>'
}

function isPrintableOrWhitespace (code) {
  return (code >= 0x20 && code <= 0x7E) || (code >= 0x09 && code <= 0x0D)
}

/**
 * VCI のログのレコード。
 */
class VciLogRecord {
  /**
   * @param type {VciLogRecord.RecordType} レコードのタイプ。
   * @param parameterMap {Map} キーペア形式のパラメーターオブジェクト。
   * @param metaElements {Object[]} メタ要素の配列。
   */
  constructor (type, parameterMap, metaElements = undefined) {
    this.type = type
    this.metaElements = metaElements || []
    this.parameterMap = parameterMap || new Map()
  }

  static get RecordType () { return VciLogRecordType }

  static get ElementTag () { return VciLogElementTag }

  static get TextParameterKey () { return '__vci_logcat_text_parameter' }

  static get FormatType () { return VciLogFormatType }

  static elementToString (element) {
    switch (element.tag) {
      case VciLogRecord.ElementTag.Tag93:
      case VciLogRecord.ElementTag.Tag91:
        return controlCodeToString(element.tag_num) + controlCodeToString(element.num)
      case VciLogRecord.ElementTag.Text:
      case VciLogRecord.ElementTag.Integer:
        return String(element.text)
      default:
        return String(element.text)
    }
  }

  toString () {
    return this.format(VciLogRecord.FormatType.Default)
  }

  /**
   * 指定したフォーマットに整形する。
   *
   * @param formatType {VciLogRecord.FormatType} フォーマットを指定する。
   *
   * @return フォーマットした文字列。
   */
  format (formatType) {
    switch (formatType) {
      case VciLogRecord.FormatType.JsonRecord:
        return this._formatJsonRecord()
      case VciLogRecord.FormatType.FullText:
        return this._formatFullText()
      default:
        return this._formatDefault()
    }
  }

  _formatDefault () {
    if (this.type !== VciLogRecordType.Logger) {
      // 不明な形式の場合は、すべての要素を文字列化する
      return this._formatFullText()
    }

    //
    let str = 'Log'

    const timeString = this.parameterMap.get('UnixTime')
    if (timeString !== undefined) {
      const time = Number.parseInt(timeString, 10)
      if (Number.isFinite(time)) {
        const date = new Date(time * 1000)
        str += ` | ${('0' + date.getHours()).slice(-2)}:${('0' + date.getMinutes()).slice(-2)}:${('0' + date.getSeconds()).slice(-2)}`
      }
    }

    for (let key of ['Category', 'Item', 'Message']) {
      const value = this.parameterMap.get(key)
      if (value !== undefined) {
        str += ` | ${value}`
      }
    }

    return str
  }

  _formatJsonRecord () {
    let parameters = {}

    for (let [key, value] of this.parameterMap) {
      parameters[key] = value
    }

    return JSON.stringify({
      type: this.type,
      meta_list: this.metaElements.map(element => VciLogRecord.elementToString(element)),
      parameters: parameters
    })
  }

  _formatFullText () {
    let str = ''

    for (let element of this.metaElements) {
      str += (str ? ' | ' : '') + VciLogRecord.elementToString(element)
    }

    for (let [key, value] of this.parameterMap) {
      if (key === VciLogRecord.TextParameterKey) {
        str += (str ? ' | ' : '') + value
      } else {
        str += (str ? ' | ' : '') + key + ' = ' + value
      }
    }

    return str
  }
}

class LexReader {
  /**
   * @param data {Uint8Array} ログのバイナリデータ。
   */
  constructor (data) {
    if (!data || !Number.isFinite(data.length)) {
      throw new TypeError(`Invalid data type: ${typeof data}`)
    }
    this.data = data

    this.pos = 0
    this.end = data.length
  }

  get done () {
    return this.pos >= this.end
  }

  next () {
    if (this.done) {
      return undefined
    }

    const cc = this.data[this.pos]
    ++this.pos
    return cc
  }

  peek () {
    return this.done ? undefined : this.data[this.pos]
  }

  readString (size = undefined, encoding = 'utf8') {
    if (size < 0) {
      throw new RangeError('INDEX_OUT_OF_RANGE: size < 0')
    }

    if (this.done) {
      return undefined
    }

    const sliceEnd = (size === undefined) ? this.end : Math.min(this.pos + size, this.end)
    const decoder = new StringDecoder(encoding)
    const str = decoder.end(this.data.slice(this.pos, sliceEnd))
    this.pos = sliceEnd
    return str
  }
}

class VciLogRecordParser {
  /**
   * @param reader {LexReader} ログデータのリーダー。
   */
  constructor (reader) {
    this.reader = reader
  }

  /**
   * VCI のログのレコードをパースする。
   *
   * @param data {{String|Buffer|ArrayBuffer} ws.on('message') で受信したデータを指定する。
   *
   * return {VciLogRecord} パース結果のレコードオブジェクトを返す。
   */
  static parse (data) {
    if (data instanceof String || typeof data === 'string') {
      let parameterMap = new Map()
      parameterMap.set(VciLogRecord.TextParameterKey, data)
      return new VciLogRecord(VciLogRecordType.Unknown, parameterMap)
    } else if (data instanceof Buffer) {
      return new VciLogRecordParser(new LexReader(data)).exec()
    } else if (data instanceof ArrayBuffer) {
      return new VciLogRecordParser(new LexReader(new Uint8Array(data))).exec()
    } else if (Array.isArray(data)) {
      let totalSize = 0
      for (let entry of data) {
        if (entry instanceof Buffer) {
          totalSize += entry.length
        }
      }

      let totalBuffer = Buffer.allocUnsafe(totalSize)
      let destOffset = 0
      for (let entry of data) {
        if (entry instanceof Buffer) {
          entry.copy(totalBuffer, destOffset)
          destOffset += entry.length
        }
      }
      return new VciLogRecordParser(new LexReader(totalBuffer)).exec()
    } else {
      let parameterMap = new Map()
      parameterMap.set(VciLogRecord.TextParameterKey, `[Unsupported data type: ${typeof data}]`)
      return new VciLogRecord(VciLogRecordType.Unknown, parameterMap)
    }
  }

  /**
   * ログレコードのパースを実行する。
   *
   * return {VciLogRecord} パース結果のレコードオブジェクトを返す。
   */
  exec () {
    //
    let elements = []
    while (!this.reader.done) {
      elements.push(this._parseElement())
    }

    //
    if (elements.length < 2 || (elements[0].tag !== VciLogRecord.ElementTag.Tag93 && elements[1].text !== 'logger')) {
      // 不明なデータ形式の場合は、文字列化する。
      let text = ''
      for (let entry of elements) {
        text += (text ? ' ' : '') + VciLogRecord.elementToString(entry)
      }

      let parameterMap = new Map()
      parameterMap.set(VciLogRecord.TextParameterKey, text)
      return new VciLogRecord(VciLogRecordType.Unknown, parameterMap)
    } else {
      // VCI ログデータの形式として扱う
      let parameterMap = new Map()
      let metaElements = []

      // メタデータ (仮) を処理
      let index = 0
      for (; index < elements.length; ++index) {
        const entry = elements[index]
        metaElements.push(entry)
        if (entry.tag === VciLogRecord.ElementTag.Tag91) {
          ++index
          break
        }
      }

      // ログ本文 (仮) を処理
      while (index < elements.length) {
        const keyText = VciLogRecord.elementToString(elements[index++])
        const valueText = (index < elements.length) ? VciLogRecord.elementToString(elements[index++]) : ''
        parameterMap.set(keyText, valueText)
      }

      return new VciLogRecord(VciLogRecordType.Logger, parameterMap, metaElements)
    }
  }

  /**
   * ログの要素をパースする。
   *
   * return {Object}
   *          - tag: {VciLogRecord.ElementTag} タグ。
   *          - tag_num: {Number} タグ番号。
   *          - text: {String} 文字列化された内容。
   *          - num: {Number} 数値化された内容。
   */
  _parseElement () {
    if (this.reader.done) {
      return { tag: VciLogRecord.ElementTag.Unknown, tag_num: 0, text: '', num: Number.NaN }
    }

    let cc = this.reader.peek()
    if (cc >= 0x7F) {
      this.reader.next()
      if (this.reader.done) {
        return { tag: VciLogRecord.ElementTag.Unknown, tag_num: cc, text: controlCodeToString(cc), num: Number.NaN }
      }

      // VCI ログの要素情報として扱う
      if (cc === 0x93 || cc === 0x91) {
        const tag = (cc === 0x93) ? VciLogRecord.ElementTag.Tag93 : VciLogRecord.ElementTag.Tag91
        const num = this._parseNumberComponent(1)
        return { tag: tag, tag_num: cc, text: String(num), num: num }
      } else if (cc >= 0xcc && cc <= 0xcf) {
        // 0xcc から 0xcf までの場合は、1 から 4 バイトの数値として扱う。 (仮)
        const num = this._parseNumberComponent(cc - 0xcb)
        return { tag: VciLogRecord.ElementTag.Integer, tag_num: cc, text: String(num), num: num }
      } else if (cc >= 0xa0 && cc <= 0xbf) {
        // 0xa0 から 0xbf までの場合は、0xa0 を引いた値をテキストサイズとして扱う。 (仮)
        const text = this.reader.readString(cc - 0xa0)
        return { tag: VciLogRecord.ElementTag.Text, tag_num: cc, text: text, num: Number.NaN }
      } else if (cc === 0xd9) {
        // 0xd9 の場合は、次の１バイトを、テキストサイズとして扱う。 (仮)
        const text = this.reader.readString(this.reader.next())
        return { tag: VciLogRecord.ElementTag.Text, tag_num: cc, text: text, num: Number.NaN }
      } else {
        // それ以外の場合は、末尾までを不明な形式として文字列化する。 (仮)
        const text = this._parseUnformedComponent()
        return { tag: VciLogRecord.ElementTag.Text, tag_num: cc, text: text, num: Number.NaN }
      }
    } else {
      // その他の場合は、全体を不明な形式として文字列化する。 (仮)
      const text = this._parseUnformedComponent()
      return { tag: VciLogRecord.ElementTag.Text, tag_num: 0, text: text, num: Number.NaN }
    }
  }

  _parseUnformedComponent (size = undefined) {
    if (size === undefined) {
      size = Number.MAX_SAFE_INTEGER
    }
    let count = 0
    let str = ''
    let controlFlag = false
    while (!this.reader.done && count < size) {
      const cc = this.reader.next()
      if (isPrintableOrWhitespace(cc)) {
        if (controlFlag) {
          str += ' '
        }
        str += String.fromCharCode(cc)
        controlFlag = false
      } else {
        if (str) {
          str += ' '
        }
        str += controlCodeToString(cc)
        controlFlag = true
      }
      ++count
    }
    return str
  }

  _parseNumberComponent (size) {
    // バイトオーダーが不明なため、ネットワークバイトオーダーとして扱う。 (仮)
    let num = 0
    for (let i = 0; i < size; ++i) {
      if (this.reader.done) {
        break
      }

      num = (num << 8) | this.reader.next()
    }
    return num
  }
}

//
program
  .version(require('../package.json').version)
  .usage('[options]')
  .option('-c, --connect <url>', 'connect to VCI WebSocket console (Default: ws://localhost:8080)')
  .option('-f, --format <format>', 'output format (default | json_record | full_text)')
  .option('-A, --all-warnings', 'output all the warnings such as "script not return"')
  .parse(process.argv);

(url => {
  let logFormat
  if (program.format) {
    const formatOption = program.format.toLowerCase()
    const formatTypes = Object.values(VciLogRecord.FormatType)
    const formatIndex = formatTypes.indexOf(formatOption)
    logFormat = formatIndex >= 0 ? formatTypes[formatIndex] : VciLogRecord.FormatType.Default
  } else {
    logFormat = VciLogRecord.FormatType.Default
  }

  const rl = readline.createInterface({ input: process.stdin })

  const destAddress = /\w+:\/\/.*$/i.test(url) ? url : `ws://${url}`
  const ws = new WebSocket(destAddress)

  ws.on('open', () => {
    console.error('connected [%s] (press CTRL+C to quit)', destAddress)
  })

  ws.on('close', code => {
    console.error('disconnected [code: %d]', code)
    process.exit()
  })

  ws.on('error', error => {
    console.error('error: %s', error.message)
    process.exit(-1)
  })

  ws.on('message', data => {
    const record = VciLogRecordParser.parse(data)

    // TODO フィルター処理を実装
    const outputLog = !!program.allWarnings ||
                      !(record.type === VciLogRecord.RecordType.Logger && record.parameterMap.get('Category') === 'System' && /frame:\s+script\s+not\s+return/.test(record.parameterMap.get('Message'))) // 'frame: script not return' メッセージを無視する

    if (outputLog) {
      console.log(record.format(logFormat))
    }
  })

  rl.on('close', () => {
    ws.close()
    process.exit()
  })
})(program.connect || 'ws://localhost:8080')
